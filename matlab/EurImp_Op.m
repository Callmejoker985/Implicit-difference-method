function [f_mat,test1_price] = EurImp_Op(S_0,r,sigma,T,S_top,N,M)
%Function to calculate the price of a European option;
%Put or Call option using the implicit finite difference method;
%
%Inputs:__
%   :S_0 - stock price;
%   :r - risk free interest rate;
%   :sigma - volatility;
%   :T - date;
%   :S_top - the maxmum stock price we use;
%   :N - date;
%   :M - Stock price S divided into M segments;
%   :T - Time T divided into N segments.
%Outputs:__
%   :test1_price - Implicit european option price;
%   :f_mat - the Matrix generated by Implicit Difference Method.
dS = S_top / M;
dT = T / N;
S = (0:dS:S_top)';
j_vector = 0:M;
i_vector = 0:N;
%First we calculate the coefficients(a,b,c):
%in this case there is no dividend.
sigma2 = sigma * sigma;
a_j = (dT*j_vector/2).*(r - sigma2*j_vector);
b_j = 1 + dT*(sigma2*(j_vector.^2) + r);
c_j = -(dT*j_vector/2).*(r + sigma2*j_vector);
%We Pre-set a zero matrix:
f_mat = zeros(M + 1,N + 1);
% Specify the boundary conditions:
% According to the question
price(S>60) = 5;
price(S<40) = 2;
price(S<=60&S>=40) = min(max(S(S>=40&S<=60)-50,0),2);
f_mat (:,end) = price;
f_mat (1,:) = 2*exp(-r*(N-i_vector)*dT);
f_mat (end,:) = 5*exp(-r*(N-i_vector)*dT);
% Form the tridiagonal matrix
tri_mat = diag(a_j(3:M),-1) + diag(b_j(2:M)) + diag(c_j(2:M-1),1);
[L,U] = lu(tri_mat);
% Solve at each node
offset = zeros(size(tri_mat,2),1);
for idx = N:-1:1
    offset(1) = a_j(2)*f_mat(1,idx);
    offset(end) = c_j(end)*f_mat(end,idx); % This will always be zero
    f_mat(2:M,idx) = U\(L\(f_mat(2:M,idx+1) - offset));
end
%then we calculate the option price we want:
test1_price =  interp1(S,f_mat(:,1),S_0);
%plot a figure
delta = diff(f_mat(:,1)) / dS;
h = figure;
set(h,'color','w');
plot(S(1:end-1),delta)

